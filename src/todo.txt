General
  - add routines for displaying/printing the different datatypes

  - promotion rules: Circles, Lines, Bounds, Triangles, ...
     - have left them for the moment, as don't often do binary
       operations on these, but will need it for transformations (maybe)
       and maybe for constructing arrays of these things

  - Tests
     - put tests into a different directory from the sources
     - add more comprehensive tests, using @assert to check things are correct
     - perhaps put the tests that do plots in separate "examples"
         as these are no suitable for off-line testing?
     - generic tests that "universal" functions such as isin, closed, bounded, ...
       exist for all types

  - Documentation
     - how should we document everything in here
        -- auto, e.g. doxygen
	-- separate docs, e.g. using iJulia

  - Additional shapes/objects to add
     - Splines (Bezier, ...?)
         already some dicussion of B-Splines
	 	 https://groups.google.com/forum/#!topic/julia-dev/lYBoGV_iK1g
		 https://groups.google.com/forum/#!topic/econforge/SW_PbHh_OCE
     - Ellipses (and arcs)
     - other mathsy shapes/curves

  - most of my types have been made "immutable" by presumably don't
    want to do that for polygons
     - maybe not for circles? maybe not for others

  - vectorised versions of functions such as "bounded" "closed"
    vector/array versions of "isin"

point.jl
  - currently have Point and Vect as aliases for each other
       strictly a point and a vector are different, and different operators work on each
       but at the moment this just seems to be a mathematical nicety
            e.g., its convenient to be able to do (a+b)/2 to find a mid-point of points a and b
                  thought strictly should only be done with vectors

line.jl
  Haven't really implemented much of "Ray" yet 
  Conversions between Line -> Ray -> Segment (with extra information)???
  Intersections between mixed Line, Ray and Segment
  Arrays of lines, rays and segments???
  Many of the constructors for a "Line" push them towards being Float64
     which will then have an impact on later algorithms
     -- could have specialised algorithms to deal with Rationals (say)
     -- similar issues with circles etc
  intersections for Rays
  finish "distance" functions and test, and use them for "isin" functions

triangle.jl
  intersections and unions -- by converting into a polygon
     (NB: triangles aren't polygons(type) because don't store 4 points
          cause its a waste)

circle.jl (center, radius)
  arc (part of a circle)

transforms.jl
  scale
  translate
  rotate
  shear
  ???

  probably start with a transform for a "point" and "line" and build up
  do we want transforms to be "objects", with functions/operators to
     apply them, or do we just want functions?


polygons.jl
   simple OK
   almost simple, almost OK
   complex not implemented at all
      do we need a "path" made up of line segments?

   constructors
   union/intersection/differences
     -- can I create a new operator 'u' or 'n' or using Unicode
     	-- would that even be wise

   remove_colinear.m (from a path)
          including points that are really (floating point) the same

   generators
       regular (see Circles)
       star_poly
       random (convex, simple, almostsimple, ...)       

   centroid
   minkowski sum
   medial axis

   isregular
   isalmostsimple 

   not complex (no holes, can be drawn with one continous line)

   nearvertex

   implicit_vertices -- implict vertices in complex polygon

   triangulation -- decompose into triangles
      -- and ideally put it back together again as well

   simplify -- smooth edges

   distances from various objects (e.g. point, line)
   nearest vertex, nearest point, tangent vertex

   generate sample points on a polygon

   use a polygon as a clipping region for drawing some other object
      - maybe of use in filling?

bounds
   could make Bounds a special case of a rectangle???
   add standard functions to bounds???
      maybe doesn't make sense if its an abstract, but 'isin' at least
          would be useful

utilities.jl
   convex hulls
   triangulations
   distance functions (calculate distances between two objects, and
                       closest points)   

plot.jl
   conditionally include PyPlot and create routines for plotting all
   of the above, maybe in with their files, or maybe together?
      -- how to plot unbounded?

   at the moment in utilities.jl

   create
       P = displayPath(O)
   for all objects for basic plot

   perhaps create my own fill routines though

   replace add-hoc "bounds" with a Bounds object
     -- in plot, and in line.jl

   -- also really need am optional "n" argument for plot and displayPath
      so that the user can make a more or less exact approximation to
      the real curve

   add labels to vertices of a plot
   draw internal angles
   draw arrows for unbounded bits

   fill routine
      using matplotlib to start, but then
        solid color
	shading
	stripes
	cross-hatching
	speckled
	checkerboard

other issues

   -- is there really a point to having separate types for "Point" and
      "Vect"?

   -- make sure to vectorize a lot of the basic functions, e.g., area,
      perimeter, ...






